include::../../docs/asciidoc/settings.adoc[]

:toc:

== {course-3}

*Allgemeine Inhalte*

* [ ] Generics
* [ ] Streaming API
* [ ] Funktionale Programmierung mit Lambda-Ausdrücken

*Fachlicher Kontext*
----
 + eher Theorie
 + Standard-Beispiele/-Übungsaufgaben
----


=== Generics

Generische Programmierung in Java ist durch Generics seit langem möglich. Der Begriff steht synonym für "parametrisierte Typen". Die Idee ist, zusätzliche Variablen für Typen einzuführen. Diese Typ-Variablen repräsentieren zum Zeitpunkt der Implementierung unbekannte Typen. Erst bei der Verwendung der Klassen, Schnittstellen und Methoden werden diese Typ-Variablen durch konkrete Typen ersetzt. Damit kann typsichere Programmierung meistens gewährleistet werden. In der Regel wird die Codemenge durch Generics reduziert (Prinzip: `DRY`), manchmal wird er allerdings auch schwerer wartbar und abnehmende Lesbarkeit. Die folgenden zwei Varianten finden sich in der Praxis am häufigsten:

* Java Generics `Klasse`
* Java Generics `Methode`

TIP: [small]#_Viele Beispiele finden sich auch im Collections Framework, etwa die  Interfaces `List<T>` oder `Map<K,V>`. Siehe dazu z.B. -> https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/package-summary.html[Java 17 Package Documentation für `java.util`]!_#

[source,java,lines,title="Beispiel einer generischen Klasse"]
----
include::{course-3-src}/generics/Joiner.java[tag="generic-class"]
----

Zeile 1 macht die Klasse generisch, in Zeile 9 wird der unbekannte Typ genutzt.

[source,java,title="Beispiel einer generischen Methode"]
----
include::{course-3-src}/generics/Printer.java[tag="generic-method"]
----


=== Streaming (API)

Zur verbesserten Verarbeitung von "Listen" in Java wurden spezielle Methoden durch "streaming" mit Java 8 eingeführt. Häufig wird der Begriff `filter-map-reduce` genutzt, um diese Möglichkeiten zusammenzufassen.

Beispiele siehe

 course-3/test/de/dhbw/course3/streaming/StreamingTest.java

`Filter`

Bei der Anwendung mehrerer oder komplexer Filteroperationen sollte die Performanz beachtet werden. Hier eine Einschätzung:

.Performanz bei komplexen Filteroperationen
image::images/FilterPerformance.png[width="100%",align="center"]

`Map`

_"Mapping"_ Operationen auf Listen transformieren diese. Methoden oder Klassen, deren Zweck die Abbildung von Klassen in andere Strukturen implementieren, werden häufig _"mapping"_ Methoden genannt, daher hier dieser Term hier ebenfalls genutzt.

Besonders die Veränderung der Datentypen der Listenelemente ist ein wichtiger Anwendungsfall beim Einsatz von `map(...)`.

`Reduce`

`Stream.reduce()` Operation reduzieren die Ausgangsdatenmenge. Dies erfolgt in Teilschritten:

* `Identity` – Ein Element mit einem initialen Wert für die Reduktionsoperation und der "default return value" wenn der Stream leer sein sollte.
* `Accumulator` – Eine Funktion mit zwei Parametern: ein Teilergebnis der Reduktionsoperation und das nächste Element des Streams.
* `Combiner` – Eine Funktion um die Teilergebnisse (der Reduktionsoperation) zu kombinieren wenn `reduce` parallelisiert wird.

Richtig nutzbringend ist oft erst die Kombination `filter`, `map` und `reduce` Operationen, um aus Daten *Informationen* zu gewinnen.

Dazu ein Beispiel:

[source,java,title="Beispiel einer reduce() Operation"]
----
include::{course-3-test}/streaming/StreamingTest.java[tag="reduce-example"]
----

Übung am Beispiel - Warenkorb mit Produkten:

 course-3/test/de/dhbw/course3/study/MyStudyTests.java


=== Funktionale Programmierung

{tbd}
