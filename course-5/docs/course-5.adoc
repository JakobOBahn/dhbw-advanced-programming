include::../../docs/asciidoc/settings.adoc[]

== {course-5}

////
*Allgemeine Inhalte*

* Beziehungen zwischen Systemen oder Komponenten (Call, ...)
* synchron vs. asynchron
* synchron
** Method Calls
** REST (SOAP?)
** RMI
* asynchron
** publish/subscribe
** fire & forget
////

Ganz allgemein umfasst der Begriff *Integration* das Ziel, verschiedene Applikationen zusammen arbeiten zu lassen, um einen einheitlichen Satz an Funktionalität bereitzustellen. Hierbei werden viele Teilbereiche berührt, z.B.

* Integration auf verschiedenen *Ebenen* (Mikro- bis Makro)
* Integration mit unterschiedlichen *Technologien* (Frameworks, Protokolle)
* Unterschiedliche Integrations-*Zwecke* (Daten, Funktionen)
* Integration durch unterschiedliche *Stile* (Methoden, Architekturen)

*Was kann miteinander integriert werden?*

So gut wie alles, d.h. unter anderem ...

image::diagrams/integration-overview.svg[width="100%"]


=== Kriterien

Um Daten, Funktionen, Services oder Anwendungen integrieren zu können, müssen viele Aspekte beachtet werden. Eine *gute Integration* muss entsprechend all die Erfordernisse, Komplexitäten Konsequenzen berücksichtigen. D.h., die Auswahl dessen, "was" und "wie" integriert wird, bedarf einer guten Entscheidungsgrundlage. Die folgenden *Kriterien* helfen bei diesen Überlegungen:

Standalone vs. Distributed::
Muss überhaupt integriert werden?

Lose vs. enge Kopplung (Grad der Integration)::
Wie viele Dinge/Aspekte und wie "eng" muss integriert werden? Wie unabhängig sind die integrierten Komponenten. Wie unabhängig sollen/müssen diese überhaupt sein? (Prinzip: _Loose Coupling_)

Simpel vs. Komplex (Einfachheit der Integration)::
Je komplexer eine Integration ist, desto schwieriger wird die Wartung und Weiterentwicklung sein. Das ist besonders dann relevant, wenn die integrierten Komponenten von unterschiedlichen Teams entwickelt werden. Also, je simpler, desto eher kann das "Zusammenwirken" der integrierten Teile evolvieren.
(Prinzip: _Minimum Impact_)

Technologie::
Welche Technologie soll/muss genutzt werden. Hier gibt es eine starke Abhängigkeit vom "Use Case" bzw. von den Erfordernissen der Fachlichkeit.

_Beispiel: Ein Überwachungssystem von Zügen muss Echtzeitdaten verarbeiten, d.h. alle Integrationsaspekte müssen diese Echtzeitverarbeitung ebenfalls unterstützen, wodurch die Auswahl der möglichen Technologien eingeschränkt wird._

Datenformat::
Integrierte Applikationen müssen sich in aller Regel über die ausgetauschten Daten einigen, entsprechend ist zu entscheiden, ob die übertragenen Daten einen "Vertrag" oder ein "Protokoll" erfüllen müssen oder ob es nur simple Daten ohne große Struktur handelt. Bestimmte Technologien adressieren diesen Punkt, z.B. _OpenAPI_ oder _Avro_.

Datenaktualität::
Wann und wie häufig (Frequenz) sollen integrierte System miteinander kommunizieren?

Daten vs. Funktionen::
Siehe Diagramm oben. Was muss integriert werden. Sind es nur (z.B. gemeinsam genutzte) Daten in einer Datenbank oder sollen ganze Services nutzbar sein?

Synchron vs. Asynchron::
Müssen Integrationsprozesse (Aufrufe) direkt beantwortet werden oder kann die Anfrage von der Antwort entkoppelt werden, sodass sie zeitlich nicht voneinander abhängig sind?

_Zwei bekannte Beispiele für ..._

* synchrone Kommunikation: `RESTful Webservices`
* asynchrone Kommunikation: `Messaging`


=== Integrationsoptionen bzw. -muster


. *File Transfer*. Wenn eine Anwendung Dateien für andere bereitstellen will, so können diese einfach ausgetauscht werden. Viele Im- und Export-Prozesse nutzen dieses Muster.

image::images/FileTransfer.png[width="40%"]

[start=2]
. *Shared Database*. Daten können - quasi im Hintergrund - einfach über eine gemeinsam genutzte Datenbank "ausgetauscht" werden. Hieraus ergeben sich natürlich weitere Fragestellungen, wie etwa die Einhaltung des ACID Prinzips (_Atomicity, Consistency, Isolation und Durability_).

image::images/SharedDatabase.png[width="40%"]

[start=3]
. *Remote Procedure Invocation*. Wenn nicht Daten, sondern _"Verhalten"_ bereitgestellt werden, so können dieses von anderen Applikationen genutzt werden. Das Verhalten kann bspw. als Funktionen, Algorithmen, Logiken, Services oder ganze Geschäftsprozesse implementiert sein. Die Nutzung erfolgt dabei i.d.R. "remote", kann aber natürlich auch innerhalb einer Software auf diese Weise realisiert werden (z.B. über _"Service Meshes"_).

image::images/RemoteProcedureInvocation.png[width="40%"]

[start=4]
. *Messaging*. Verteilte, unabhängige Systeme kommunizieren über eine (zentrale, gemeinsame) Messaging Plattform. Hier können sowohl Daten als auch Funktionen Gegenstand der Kommunikation sein.

image::images/Messaging.png[width="40%"]
