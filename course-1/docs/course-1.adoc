include::../../docs/asciidoc/settings.adoc[]

:toc:

== {course-1}

=== Inhalte

*Setup*:

- [ ] IDE (IntelliJ & Visual Studio Code), Java (Installation, etc. ...)
- [ ] Test-Driven-Development
- [ ] Unit-Tests mit JUnit

*Theorie & Objektmodell*:

- [ ] Klassen & Objekte
- [ ] Objektvertrag (hashCode, equals)
- [ ] Vererbung & Interfaces
- [ ] Abstrakte Klassen
- [ ] Beziehungsarten (Besitz, Aufruf, Vererbung, ...), Aggregation vs. Komposition etc.
- [ ] Referenzsemantik

=== Fachlicher Kontext

----
Vorbereitung: Darstellung des fachlichen Kontextes

 + Überwachungssystem in der Betriebsleitung

 + Zug, Zugtypen, Triebfahrzeug (Tbf), Wagons
 + Streckennetz

 + Fahrplan

 + Störung, Weichenausfall, Abfahrt, Ankunft (z.B. verspätete Ankunft im Bahnhof)
 + Dispositionsmaßnahme (z.B. Umleitung)
----

Der Zugbetrieb kann grundsätzlich unterteilt werden in:

. *infrastrukturelle* Sicht (_Stammdaten_)
. *planerische* Sicht auf den Betrieb (_Bewegungsdaten, SOLL_)
. *operative* Sicht auf den Betrieb (_Bewegungsdaten, IST_)

Ein paar Begriffe in der Übericht:

image::diagrams/business-model.svg["Fachbegriffe",width="75%",align="center"]

=== Technisches Setup

==== Github

Das Repository mit den Sourcen für dieses Seminar befindet sich hier:

 https://github.com/ThorstenEckstein/dhbw-advanced-programming

Zunächst muss das Repository geklont werden für die lokale Kopie:

 git clone https://github.com/ThorstenEckstein/dhbw-advanced-programming.git

Dann bitte direkt auf den Branch `hands-on` durch

 git checkout -b hands-on

wechseln.


==== Einrichtung von IntelliJ (empfohlen)

* ... Jakob's Test und Doing ...


==== Klassenmodell

Die Fachlichkeit (s.o.) kann in einem (Fach-) *Klassenmodell* abgebildet werden, z.B. mit folgenden Objekten:

----
 + Zug (Zugarten), Wagons (Wagonarten)
 + Strecke, Abschnitt, Gleis
 + Ereignisse: Abfahrt, Ankunft
 + Fahrt

 (+ Dispositionsmaßnahme, Umleitung)
----

Überblick über das grundsätzliche *Fachklassenmodell* in zwei "Geschmacksrichtungen":

*Infrastrukturelle* Sicht (statische Sicht):

[plantuml, "Klassenmodell", png, align="center"]
....
include::diagrams/business-model-ist.puml[]
....

*Planerische* Sicht (dynamische Sicht):

[plantuml, "Klassenmodell", png, align="center"]
....
include::diagrams/business-model-soll.puml[]
....


Das Interface `Train` sieht dabei vielleicht so aus:

[source, java, linenums]
----
include::{course-1-src}/model/train/Train.java[lines=5..13]
----

Für mehr Einblicke in das Modell und die Objekterzeugung, siehe auch

 test/de/dhbw/course1/model/ModelTest.java


=== Test Driven Development (`TDD`)

Test Driven Development (`TDD`) ist eine gute Praxis, um den Sourcecode von Beginn an - mithilfe von Unit-Tests regelmäßig und bei Änderungen auf Korrektheit zu überprüfen. Die erste Umsetzung erfolgt vielfach durch Testklassen, den `Unit-Tests`.

Unit-Tests haben folgende *Eigenschaften*:

. Unit-Tests sind *automatisiert*. Ein Unit-Test-Framework führt Tests aus, verifiziert und gibt das Ergebnis zurück, damit es geprüft werden kann
. Unit-Tests sind *granular*, sie sollen nur einen kleinen Teil des Codes -häufig eine Methode - testen.
. Unit-Tests *isolieren* das Testziel und sollen möglichst ohne oder nur mit wenig "Vorbereitungen" gestartet werden können
. Unit-Tests sind *deterministisch*, damit das Testergebnis sauber geprüft werden kann und wiederholt werden kann
. Unit-Tests sind *unabhängig*. Die Ausführung der Tests dürfen in keiner Weise von anderen Testmethoden abhängen, denn die Reihenfolge der vom Framework ausgeführten Tests ist zufällig bzw. nicht vorhersagbar.

*Umsetzung*:

Unit-Tests weisen eine besondere (innere) Struktur auf, d.h. die Art und Weise, wie diese geschrieben werden. Dazu zählen

* `given-when-then` oder
* `arrange-act-assert`.

*Vorgehensweise*:

Auch das Schreiben von Tests folgt vielfach einer Routine bzw. einer "best practice". Neben zahlreichen gleichwertigen Ansätzen ist die so-genannte `"red, green, refactor"` Methode weitestgehend anerkannt.

image::images/tdd-red-green-refactor.png[align="center", width="50%"]

*Red, Green, Refactor*:

Der "red, green, refactor" Ansatz hilft Entwicklern, den (zu implementierenden) Code zu entwickeln, indem sie den Fokus in den Phasen auf bestimmte Aspekte lenken:

. [red]#*Red*#: _Was soll implementiert werden und wie fühlt sich das Ganze aus Sicht des "Clients" bzw. der Nutzer an?_ Nutzer sind hier primär die Entwickler selbst bzw. diejenigen, die die Klassen, Methoden, Algorithmen im Code aufrufen, also nutzen wollen. In dieser Phase _soll_ der Test noch scheitern, d.h. "rot" sein, weil hier nicht die Implementierung an sich, sondern die "Außensicht" auf die `API` im Vordergrund steht.

. [green]#*Green*#: In dieser Phase geht es darum, den Test _"zum Laufen"_ zu bringen. Es wird also "grün". Im Vordergrund steht die _schnellste und einfachste Implementierung_ der Funktionalität. Der Code wird hier also nur technisch funktionsfähig gemacht, es werden aber so wenig wie möglich Überlegungen angestellt, wie der Code gut, schön oder effektiv geschrieben werden muss.

. [blue]#*Refactor*#: In dieser letzten Phase (dieser Iteration) geht es nun genau darum, was in den beiden vorherigen Phasen absichtlich nicht gemacht werden sollte, nämlich die Verbesserung des Codes hinsichtlich seiner "Qualität" (das Thema Code-Qualität wird gegen Ende des Seminars noch näher betrachtet). Ergebnis dieser (drei) Phasen soll dann ein Unit-Test sein, der lesbar und wartbar ist und auch die Implementierung der Funktionalität einen bestimmten Reifegrad bzw. eine erste hinreichende Qualität erreicht hat, und natürlich letztlich die korrekte Funktionalität liefert.

Dazu ein *Beispiel*:

 test/de/dhbw/course1/tdd/TddByExampleTest.java


=== Objektvertrag (object contract)

The Object class defines both the `equals()` and `hashCode()` methods, which means that these two methods are implicitly defined in every Java class, even if they are not implemented explicitly.

The default implementation of `equals()` in the Object class says that *equality* is the same as object *identity*.

[source, java, linenums, title="Gleich oder Identisch?"]
----
include::{course-1-test}/basics/BasicsTest.java[tag="object-contract-1"]
----

[source, java, linenums, title="Gleich oder Identisch?"]
----
include::{course-1-test}/basics/BasicsTest.java[tag="object-contract-2"]
----


=== Reference Semantics

*Example 1*: "_pass by value_"

In the *pass by value* concept, the method is called by passing a value. The argument is a copy of the original one. This is called 'pass by value'. It does not affect the original parameter.

[source, java, linenums, title="Reference Sematics Bsp. mit Primitiven"]
----
include::{course-1-test}/basics/BasicsTest.java[tags="ref-semantics-prim"]
----

image::diagrams/reference-semantics-prim.svg["RefSemPrim",width="50%",align="center"]


*Example 2*: "_pass reference and update its' state_"

Although the argument variable is passed in, the reference itself is copied. The object that is really referenced is still the same and can thus be changed!

[source, java, linenums, title="Reference Semantics Bsp. mit Objekten"]
----
include::{course-1-test}/basics/BasicsTest.java[tags="ref-semantics-obj"]
----

image::diagrams/reference-semantics-obj.svg["RefSemObj",width="50%",align="center"]


// ---------------------- HIDDEN ----------------------
.Click to reveal details for *Example 3*: "_pass by reference_"
[%collapsible]
====
*Example 3*: "_pass by reference_"

In the *pass by reference* concept, the method is called using an alias or reference of the actual parameter. This is called pass by reference. It forwards the unique identifier of the object to the method. If we make changes to the parameter's instance member, it would affect the original value.

CAUTION: [red]#_Java does not support pass by reference concept!_#

//[subs="normal"]
//----
//include::{course-1-test}/basics/BasicsTest.java[tags="ref-semantics-2"]
//----
====
// ---------------------- HIDDEN ----------------------


Ein weiteres Beispiel für *Reference Semantics*:

image::diagrams/reference-semantics.svg["RefSem",width="100%",align="center"]

[cols="^1,9a", grid="none", frame="none"]
|===
| # | Erläuterung/Kommentar

| [yellow]#(1)#
| Erzeugung einer Variable `a1` vom Typ `Account` mit Zuweisung zur neuen Instanz sowie der Initialisierung des Attributes `amount` mit dem Wert `0`

[source,java,indent=0]
----
include::{course-1-test}/basics/BasicsTest.java[lines="69"]
----

| [yellow]#(2)#
| Aus Sicht der Methode `process(Account acc)` wird eine Variable `acc` definiert, sie hat initial den Wert `null`

[source,java,indent=0]
----
include::{course-1-src}/basics/refsemantics/Account.java[lines="22"]
----

| [yellow]#(3)#
| Beim Aufruf der Methode `process(a1)` wird der Wert bzw. die "Adresse" der Variable `a1`  nach `acc` kopiert (_"copy-by-value"_)

//include::{course-1-test}/basics/BasicsTest.java[lines="73"]
[source,java,indent=0]
----
        Account.process(a1)
----

| [yellow]#(4)#
| Hier wird (einfach) eine neue Instanz `a2` von `Account` angelegt, sie hat zunächst nichts mit den vorhergehenden Dingen zu tun. Bei dieser zweiten Instanz wird das Attribut `amount` allerdings gleich dem Wert `100` initialisiert

[source,java,indent=0]
----
include::{course-1-src}/basics/refsemantics/Account.java[lines="24"]
----

| [yellow]#(5)#
| Bei der Zuweisung von `acc = a2` wird die Referenz auf die neue Instanz "gelenkt"

[source,java,indent=0]
----
include::{course-1-src}/basics/refsemantics/Account.java[lines="25"]
----

| [yellow]#(6)#
| Hier wird der interne Status der Instanz von `Account`, nämlich der Attributwert von `amount` um `250` erhöht, der Objektzustand wird also verändert!

[source,java,indent=0]
----
include::{course-1-src}/basics/refsemantics/Account.java[lines="27"]
----
|===


=== Übungen


Übungsaufgabe 1::
Erzeuge ein kleines Klassenmodell aus dem folgenden Anwendungsfall:

-> _"Ein Bahnhof besteht aus einer Wartehalle und Bahnsteigen mit je mindestens 1 oder 2 Gleisen. Bahnhöfe werden zudem nach Fern- und Regionalbahnhöfen differenziert."_


Übungsaufgabe 2::
Versuche "Reference Semantics" grafisch zu erläutern!

Weitere Übungen::
In der Testklasse finden sich weitere kleine Übungen für die Inhalte des Kurses 1:

[subs=attributes]
 {course-1-exam}/ExamTest.java


=== Tipps, Patterns & Best Practices

